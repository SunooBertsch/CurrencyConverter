(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.RTM = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {
	        function F() {}

	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                F.prototype = this;
	                var subtype = new F();

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init')) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
},{}],3:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex != -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            var words = [];
	            var nBytes = 0;
	            for (var i = 0; i < base64StrLength; i++) {
	                if (i % 4) {
	                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
	                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
	                    var bitsCombined = bits1 | bits2;
	                    words[nBytes >>> 2] |= (bitsCombined) << (24 - (nBytes % 4) * 8);
	                    nBytes++;
	                }
	            }

	            return WordArray.create(words, nBytes);
	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };
	}());


	return CryptoJS.enc.Base64;

}));
},{"./core":2}],4:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./md5"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./md5", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.HmacMD5;

}));
},{"./core":2,"./hmac":5,"./md5":6}],5:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
},{"./core":2}],6:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":2}],7:[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],8:[function(require,module,exports){
var hmac = require('crypto-js/hmac-md5');
var base64 = require('crypto-js/enc-base64');
var objectAssign = require('object-assign');

var AUTH_METHOD = 'role_secret';

function hmacMd5(message, key) {
  var h = hmac(message, key);
  return base64.stringify(h);
}

function success(state) {
  clearTimeout(state.timerId);
  state.onsuccess();
}

function fail(state, reason) {
  clearTimeout(state.timerId);
  state.onfail(reason);
}

function send(request, state, onSuccess) {
  state.rtm._unsafeSend(request, function (pdu) {
    try {
      if (pdu.action.endsWith('/ok')) {
        onSuccess(pdu);
      } else {
        fail(state, pdu);
      }
    } catch (e) {
      fail(state, e);
    }
  });
}

function authenticate(state, nonce) {
  var hash = hmacMd5(nonce, state.roleSecret);
  var request = {
    action: 'auth/authenticate',
    body: {
      method: AUTH_METHOD,
      credentials: { hash: hash },
    },
  };
  send(request, state, success.bind(null, state));
}

function handshake(state) {
  var request = {
    action: 'auth/handshake',
    body: {
      method: AUTH_METHOD,
      data: { role: state.role },
    },
  };
  send(request, state, function (pdu) {
    var nonce = pdu.body.data.nonce;
    authenticate(state, nonce);
  });
}

function roleSecretAuthProvider(role, roleSecret, opts) {
  var defaults = { timeout: 30000 };
  if (typeof role !== 'string') {
    throw new TypeError('"role" is missing or invalid');
  }
  if (typeof roleSecret !== 'string') {
    throw new TypeError('"roleSecret" is missing or invalid');
  }
  return function (rtm, onsuccess, onfail) {
    var state = objectAssign(defaults, opts, {
      rtm: rtm,
      role: role,
      handshakeReply: null,
      onsuccess: onsuccess,
      onfail: onfail,
      roleSecret: roleSecret,
    });

    var timerId = setTimeout(function () {
      fail(state, new Error('authentication timeout'));
    }, state.timeout);
    state.timerId = timerId;

    handshake(state);
  };
}

module.exports = {
  hmacMd5: hmacMd5,
  roleSecretAuthProvider: roleSecretAuthProvider,
};

},{"crypto-js/enc-base64":3,"crypto-js/hmac-md5":4,"object-assign":7}],9:[function(require,module,exports){
(function (process){
/* eslint-disable no-console */

var logger;
var hasConsole = console && console.log;
var debugMode = false;

if (typeof process !== 'undefined' && 'DEBUG_SATORI_SDK' in process.env) {
  debugMode = process.env.DEBUG_SATORI_SDK.toLowerCase() === 'true';
}

logger = {
  DEBUG: debugMode,
  error: function (error) {
    if (hasConsole) {
      console.log.apply(console, arguments);
      if (error.stack) {
        console.log(error.stack);
      }
    }
  },
  warn: function () {
    if (hasConsole) {
      console.warn.apply(console, arguments);
    }
  },
  debug: function () {
    if (logger.DEBUG && hasConsole) {
      console.log.apply(console, arguments);
    }
  },
};

module.exports = logger;

}).call(this,require('_process'))
},{"_process":1}],10:[function(require,module,exports){
var cMap;

if (typeof (Map) !== 'undefined' && 'forEach' in Map.prototype) {
  module.exports = Map;
} else {
  cMap = function () {
    this.storage = {
      keys: [],
      values: [],
    };
    this.size = 0;
  };

  /**
   * Sets a value for the specified key.
   *
   * @param {string} key - Key value.
   * @param {any} value - Stored value.
   *
   * @return {void}
   */
  cMap.prototype.set = function (key, value) {
    var index = this._index(key);
    if (index >= 0) {
      this.storage.values[index] = value;
    } else {
      this.storage.keys.push(key);
      this.storage.values.push(value);
    }

    this.size = this.storage.keys.length;
  };

  /**
   * Gets the value for specified key
   *
   * @param {string} key - Key value.
   *
   * @return {any} if key exists; {undefined} otherwise.
   */
  cMap.prototype.get = function (key) {
    var index = this._index(key);

    return index >= 0 ? this.storage.values[index] : undefined;
  };

  /**
   * Deletes the key and the associated key value.
   *
   * @param {string} key - Key value to delete.
   *
   * @return {void}
   */
  cMap.prototype.delete = function (key) {
    var index = this._index(key);
    if (index >= 0) {
      this.storage.keys.splice(index, 1);
      this.storage.values.splice(index, 1);
    }

    this.size = this.storage.keys.length;
  };

  /**
   * Clears Map values.
   *
   * @return {void}
   */
  cMap.prototype.clear = function () {
    this.storage.keys = [];
    this.storage.values = [];

    this.size = this.storage.keys.length;
  };

  cMap.prototype._index = function (key) {
    return this.storage.keys.indexOf(key);
  };

  module.exports = cMap;
}

},{}],11:[function(require,module,exports){
var logger = require('./logger.js');

/**
 * Creates an observer instance.
 * @class
 */
function Observer() {
  this.handlers = {};
}

Observer.prototype = {
  /**
   * Attaches an event handler function for the event specified in <code>name</code>.
   *
   * The event is usually related to a client or subscription state. It may also be an event
   * that occurs when the client or subscription receives information from RTM. For example, the
   * the following are [RTM]{@link RTM} client events:
   * <ul>
   *     <li><code>data:</code> The client received a PDU from RTM.</li>
   *     <li><code>enter-connected:</code> The client is now connected to RTM.</li>
   * </ul>
   * A possible event for a [Subscription]{@link Subscription} is <code>enter-subscribed</code>.
   *
   * The <code>fn</code> parameter is a function that's invoked when the event occurs. The PDU for
   * the event is passed to this function.
   *
   * @param {string} name - event name
   *
   * @param {function} fn - event handler function
   *
   * @return {void}
   */
  on: function (name, fn) {
    if (!(name in this.handlers)) {
      this.handlers[name] = [];
    }
    this.handlers[name].push(fn);
  },

  /**
   * Removes an event handler.
   *
   * The event specified in <code>name</code> is an [RTM]{@link RTM} or
   * [Subscription]{@link Subscription} event that has an attached event handler function
   * (see the <code>on()</code> function).
   *
   * The Protocol Data Unit (PDU) for the event is passed to the
   * <code>fn</code> function parameter.
   *
   * @param {string} name - event name
   *
   * @param {function} fn - event handler function
   *
   * @return {void}
   */
  off: function (name, fn) {
    if (!(name in this.handlers)) {
      return;
    }
    this.handlers[name] = this.handlers[name].filter(function (item) {
      return item !== fn;
    });
  },

  /**
   * Executes all handlers attached for the specified event type.
   *
   * The event specified in <code>name</code> is an [RTM]{@link RTM} or
   * [Subscription]{@link Subscription} event that has an attached event handler function
   * (see the <code>on()</code> function).
   *
   * @param {string} name - name of an event that has attached handlers
   * @param {...Object} args - event arguments.
   *
   * @return {void}
   */
  fire: function () {
    var name;
    var fns;
    var i;
    var len = arguments.length;
    // Copy arguments to solve 'Not optimized: Bad value context for arguments value'
    // See https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
    var args = new Array(len);
    for (i = 0; i < len; i += 1) {
      args[i] = arguments[i];
    }
    name = args.shift();

    fns = this.handlers[name] || [];
    fns.forEach(function (fn) {
      try {
        fn.apply(null, args);
      } catch (e) {
        logger.error(e);
      }
    });
  },
};

module.exports = Observer;

},{"./logger.js":9}],12:[function(require,module,exports){
var W3CWebSocket = require('./websocket.js');
var Observer = require('./observer.js');
var Subscription = require('./subscription.js');
var logger = require('./logger.js');
var auth = require('./auth.js');
var objectAssign = require('object-assign');
var CMap = require('./map.js');

var RTM_VER = 'v2';
var STOPPED = 'stopped';
var CONNECTING = 'connecting';
var CONNECTED = 'connected';
var AWAITING = 'awaiting';
var STATES = {};


/**
 * Create a RTM client instance.
 * @class
 * @augments Observer
 *
 * @description
 * An RTM client is the main entry point for accessing RTM.
 *
 * To connect a client to RTM, you must call [RTM.start()]{@link RTM#start}. The RTM SDK attempts
 * to reconnect to RTM if the connection to RTM fails for any reason.
 *
 * A client instance can be in one of the following connection states:
 *  - <strong>stopped:</strong> You called [RTM.stop()]{@link RTM#stop} or RTM disconnected and
 *    hasn't yet reconnected.
 *  - <strong>connecting:</strong> You called [RTM.start()]{@link RTM#start} or the client is
 *    trying to reconnect to RTM.
 *  - <strong>connected:</strong> The client is connected to RTM.
 *  - <strong>awaiting:</strong> The client disconnected and is waiting the specified time period
 *    before reconnecting. See the <code>minReconnectInterval</code> and
 *    <code>maxReconnectInterval</code> options.
 *
 * For each state, an event occurs when the client enters or leaves the state. Call
 * [RTM.on(name, fn)]{@link RTM#on} method to add code that's executed when the client
 * transitions into or out of a state. The syntax for the value of <code>name</code> is
 *
 * <code><strong>[ enter- | leave- ][ stopped | connecting | connected | awaiting ]</strong></code>
 *
 * For example, <code>RTM.on("enter-connected", myFunction)</code>. The next example also shows you
 * how to call <code>RTM.on()</code>
 *
 * @example
 * // Creates an RTM client
 * var rtm = new RTM('YOUR_ENDPOINT', 'YOUR_APPKEY');
 *
 * // Creates a new subscription to the channel named 'your-channel'
* var subscription = rtm.subscribe('your-channel', RTM.SubscriptionMode.SIMPLE);
 *
 * // Adds a subscription event listener that logs messages to the console as they arrive.
 * // The subscription receives all messages in the subscribed channel
 * subscription.on('rtm/subscription/data', function (pdu) {
 *     pdu.body.messages.forEach(console.log);
 * });
 *
 * // Sets a connection event listener that publishes a message to the channel named
 * // <code>your-channel</code>
 * // when the client is connected to RTM (the client enters the 'connected' state)
 * rtm.on('enter-connected', function () {
 *   rtm.publish('your-channel', {key: 'value'});
 * });
 *
 * // Sets a client event listener that checks incoming messages to see if they indicate an error.
 * // <code>rtm.on()</code> is called for all incoming messages.
 * rtm.on('data', function (pdu) {
 *   if (pdu.action.endsWith('/error')) {
 *     rtm.restart();
 *   }
 * });
 *
 * // Starts the client
 * rtm.start();
 *
 * @param {string} endpoint - WebSocket endpoint for RTM
 * Available from the Dev Portal.
 *
 * @param {string} appkey - appkey used to access RTM
 * Available from the Dev Portal.
 *
 * @param {object} opts - additional RTM client parameters
 *
 * @param {integer} [opts.minReconnectInterval=1000] - minimum
 * time period, in milliseconds, to wait between reconnection attempts
 *
 * @param {integer} [opts.maxReconnectInterval=120000] - maximum
 * time period, in milliseconds, to wait between reconnection attempts
 *
 * @param {boolean} [opts.heartbeatEnabled=true] - enables periodic
 * heartbeat monitoring for the WebSocket connection
 *
 * @param {object} [opts.authProvider] - object that manages authentication for the client.
 * See {@link auth.js}
 *
 * @param {integer} [opts.heartbeatInterval=60000] - interval,
 * in milliseconds, to wait between heartbeat messages
 * @param {integer} [opts.highWaterMark=4194304] - 4MB. High water mark in bytes. If the number
 * of bytes in the WebSocket write buffer exceeds this value,
 * [writeable]{@link RTM#writeable} is set to <code>false</code>.
 *
 * @param {integer} [opts.lowWaterMark=2097152] - 2MB. Low water mark, in bytes. If the
 * Websocket write buffer rises above <code>highWaterMark</code> and then drops below
 * <code>lowWaterMark</code>, [writeable]{@link RTM#writeable} is set to <code>true</code>.
 *
 * @param {integer} [opts.checkWritabilityInterval=100] - Interval,
 * in milliseconds, between checks of the queue length and updates of the
 * [writeable]{@link RTM#writeable} property if necessary.
 *
 * @param {object} [opts.proxyAgent] - proxy server agent.
 * A custom http.Agent implementation like:
 * https-proxy-agent https://github.com/TooTallNate/node-https-proxy-agent#ws-websocket-connection-example
 * socks-proxy-agent https://github.com/TooTallNate/node-socks-proxy-agent#ws-websocket-connection-example
 *
 * @property {boolean} writable - A general indicator of the status of the write buffer.
 * <code>true</code> indicates that the write buffer is shrinking, while <code>false</code>
 * indicates that the write buffer is growing. Test <code>writable</code> to see whether you should
 * continue to write or pause writing.
 *
 * @throws {TypeError} <code>TypeError</code> is thrown if mandatory parameters are
 * missing or invalid.
 */
function RTM(endpoint, appkey, opts) {
  if (typeof endpoint !== 'string') {
    throw new TypeError('"endpoint" is missing or invalid');
  }
  if (typeof appkey !== 'string') {
    throw new TypeError('"appkey" is missing or invalid');
  }
  // superclass constructor call
  Observer.call(this);
  this.options = objectAssign({
    minReconnectInterval: 1000,
    maxReconnectInterval: 120000,
    heartbeatInterval: 60000,
    heartbeatEnabled: true,
    highWaterMark: 1024 * 1024 * 4, // 4Mb is the maximum queue length. Writable flag sets to false
    lowWaterMark: 1024 * 1024 * 2, // 2Mb unblock the writing. Writable flag sets to true
    checkWritabilityInterval: 100,
  }, opts);
  this.endpoint = this._appendVersion(endpoint) + '?appkey=' + appkey;
  this.reconnectCount = 0;
  this.lastId = 0;
  this.ws = null;
  this.reconnectTimer = null;
  this.subscriptions = {};
  this.ackCallbacks = new CMap();
  this.maskMessage = !this._isEndpointSecure(endpoint);

  if (this.options.heartbeatEnabled) {
    this._initHeartbeatInterval();
  }
  this.writable = true;
  this._initWritableState();
  this._initConnectionFSM();
  this.on('error', logger.error);
}

RTM.logger = logger;

/**
 * @typedef SubscriptionMode
 * @type {object}
 *
 * @property {boolean} trackPosition
 * Tracks the stream position received from RTM. RTM includes the <code>position</code>
 * parameter in responses to publish and subscribe requests and in subscription data messages.
 * The SDK can attempt to resubscribe to the channel data stream from this position.
 *
 * @property {boolean} fastForward
 * If necessary, RTM fast-forwards the subscription when the SDK resubscribes to a channel.
 *
 * To learn more about position tracking and fast-forwarding, see the sections "... with position"
 * and "... with fast-forward (advanced)" in the chapter "Subscribing" in <em>Satori Docs</em>.
 */

/**
 * Subscription modes.
 *
 * @namespace
 * @readonly
 */

RTM.SubscriptionMode = {
  /**
   *
   * RTM tracks the <code>position</code> value for the subscription and
   * tries to use it when resubscribing after the connection drops and the client reconnects.
   * If the <code>position</code> points to an expired message, RTM fast-forwards to the earliest
   * <code>position</code> that points to a non-expired message.
   *
   * This mode reliably goes to the next available message when RTM is resubscribing. However,
   * RTM always fast-forwards the subscription if necessary, so it never returns an error for an
   * 'out-of-sync' condition.
   *
   * To learn more about position tracking and fast-forwarding, see the sections "... with position"
   * and "... with fast-forward (advanced)" in the chapter "Subscribing" in <em>Satori Docs</em>.
   *
   * @type {SubscriptionMode}
   * @static
   * @constant
   * @readonly
   */
  RELIABLE: {
    trackPosition: true,
    fastForward: true,
  },

  /**
   *
   * RTM doesn't track the <code>position</code> value for the
   * subscription. Instead, when RTM resubscribes following a reconnection, it fast-forwards to
   * the earliest <code>position</code> that points to a non-expired message.
   *
   * Because RTM always fast-forwards the subscription, it never returns an error for an
   * 'out-of-sync' condition.
   *
   * To learn more about position tracking and fast-forwarding, see the sections "... with position"
   * and "... with fast-forward (advanced)" in the chapter "Subscribing" in <em>Satori Docs</em>.
   *
   * @type {SubscriptionMode}
   * @static
   * @constant
   * @readonly
   */
  SIMPLE: {
    trackPosition: false,
    fastForward: true,
  },

  /**
   *
   * RTM always tracks the <code>position</code> value for the subscription and tries to
   * use it when resubscribing after the connection drops and the client reconnects.
   *
   * If the position points to an expired message, the resubscription attempt fails. RTM sends an
   * <code>expired_position</code> error and stops the subscription process.
   *
   * If the subscription is active, and RTM detects that the current <code>position</code> value
   * points to an expired message, the subscription is in an 'out-of-sync' state. In this case,
   * RTM sends an <code>out_of_sync</code> error and unsubscribes you.
   *
   * To learn more about position tracking and fast-forwarding, see the sections "... with position"
   * and "... with fast-forward (advanced)" in the chapter "Subscribing" in <em>Satori Docs</em>.
   *
   * @type {SubscriptionMode}
   * @static
   * @constant
   * @readonly
   */
  ADVANCED: {
    trackPosition: true,
    fastForward: false,
  },
};

/**
 * Creates a role-based authentication provider for the client
 * <p>
 * The role-based authentication method is a two-step authentication process based on the HMAC
 * process, using the MD5 hashing routine:
 * <ul>
 * <li>The client obtains a nonce from the server in a handshake request.</li>
 * <li>The client then sends an authorization request with its role secret key hashed with the
 * received nonce.</li>
 * </ul>
 * <p>
 * To get a role secret key for your application, go to the Dev Portal.
 *
 * @param {string} role - role name set in the Dev Portal
 *
 * @param {string} roleSecret - role secret key
 *
 * @param {object} opts - additional authentication options
 *
 * @param {integer} [opts.timeout=30000] - amount of time, in milliseconds, before the
 * authentication operation times out
 *
 * @throws {TypeError} thrown if mandatory parameters are missing or invalid
 *
 * @return {function} authentication provider for the role-based authentication method
 */
RTM.roleSecretAuthProvider = function (role, roleSecret, opts) {
  return auth.roleSecretAuthProvider(role, roleSecret, opts);
};
RTM.prototype = Object.create(Observer.prototype);

/**
 * Starts the client.
 *
 * The client begins to establish the WebSocket connection
 * to RTM and then tracks the state of the connection. If the WebSocket
 * connection drops for any reason, the JavaScript SDK attempts to reconnect.
 *
 *
 * Use [RTM.on(name, fn)][RTM.on()]{@link RTM#on} to define application functionality,
 * for example, when the application enters or leaves the
 * <code>connecting</code> or <code>connected</code> states.
 *
 * @return {void}
 */
RTM.prototype.start = function () {
  if (STOPPED !== this.state) {
    throw new Error('RTM is already started');
  }
  this.fire('start');
};

/**
 * Stops the client. The RTM SDK starts to close the WebSocket connection and
 * does not start it again unless you call [RTM.start()]{@link RTM#start}.
 *
 * Use this method to explicitly stop all interaction with RTM.
 *
 * Use [RTM.on("enter-stopped", function())]{@link RTM#on} or
 * [RTM.on("leave-stopped", function())]{@link RTM#on} to
 * provide code that executes when the client enters or leaves the <code>stopped</code> state.
 *
 * @return {void}
 */
RTM.prototype.stop = function () {
  if (STOPPED === this.state) {
    throw new Error('RTM is already stopped');
  }
  this.fire('stop');
};

/**
 * Calls [RTM.stop()]{@link RTM#stop} followed by [RTM.start()]{@link RTM#start] to
 * restart the client. RTM issues events for these client states, which you can handle with code in
 * [RTM.on(name, function())]{@link RTM#on}.
 *
 * @return {void}
 */
RTM.prototype.restart = function () {
  this.stop();
  this.start();
};

/**
 * Returns <code>true</code> if the RTM client is in the <code>stopped</code> state.
 *
 * @return {boolean} <code>true</code> if the client is in the <code>stopped</code> state,
 * otherwise <code>false</code>
 */
RTM.prototype.isStopped = function () {
  return this.state === STOPPED;
};

/**
 * Returns <code>true</code> if the client is in the <code>connected</code> state.
 *
 * In this state, the WebSocket connection to RTM is established and any requested authentication
 * has completed successfully .
 *
 * @return {boolean} <code>true</code> if the client is in the <code>connected</code> state,
 * otherwise <code>false</code>
 */
RTM.prototype.isConnected = function () {
  return this.state === CONNECTED;
};

/**
 * Returns the existing [Subscription]{@link Subscription} object for the specified subscription id.
 *
 * @param {string} subscriptionId - the id for an existing [Subscription]{@link Subscription} object
 *
 * @throws {TypeError} thrown if <code>subscriptionId</code> is missing, invalid, or if a
 * [Subscription]{@link Subscription} object with that id doesn't exist.
 *
 * @return {Subscription} the [Subscription]{@link Subscription} object
 */
RTM.prototype.getSubscription = function (subscriptionId) {
  if (typeof subscriptionId !== 'string') {
    throw new TypeError('"subscriptionId" is missing or invalid');
  }
  return this.subscriptions[subscriptionId];
};

/**
 * Creates a subscription to the specified channel.
 *
 * When you create a subscription, you can specify additional properties.
 * For example, you can add a streamview, or you can specify the
 * what the SDK does when it resubscribes after a reconnection.
 *
 * @param {string} channelOrSubId - string containing a channel id or name. If you do not
 * specify the <code>filter</code> parameter, specify the channel name. Otherwise,
 * specify a unique identifier for your subscription to this channel.
 *
 * @param {RTM.SubscriptionMode} mode
 * subscription mode. This mode determines the behaviour of the RTM SDK and RTM when resubscribing
 * after a reconnection. See [SubscriptionMode]{@link SubscriptionMode}.
 *
 * @param {object} [bodyOpts={}]
 * additional options for the subscription
 *
 *
 * @throws {TypeError} thrown if mandatory parameters are missing or invalid.
 *
 * @return {Subscription} - subscription object
 *
 * @example
 * // Creates a new RTM client
 * var rtm = new RTM('YOUR_ENDPOINT', 'YOUR_APPKEY');
 *
 * // Creates a subscription with the name 'your-channel'
 * var subscription = rtm.subscribe('your-channel', RTM.SubscriptionMode.SIMPLE);
 *
 * // Writes incoming messages to the log
 * subscription.on('rtm/subscription/data', function (pdu) {
 *     pdu.body.messages.forEach(console.log);
 * });
 *
 * // Starts the client
 * rtm.start();
 *
 * @example
 * // Creates a new RTM client
 * var rtm = new RTM('YOUR_ENDPOINT', 'YOUR_APPKEY');
 *
 * // Subscribes to the channel named 'my-channel' using a streamview
 * var subscription = rtm.subscribe('my-filter', RTM.SubscriptionMode.SIMPLE, {
 *   filter: 'SELECT * FROM my-channel WHERE object.param >= 1 OR object.id == 0',
 * });
 *
 * // Writes incoming messages to the log
 * subscription.on('rtm/subscription/data', function (pdu) {
 *   pdu.body.messages.forEach(console.log);
 * });
 *
 * // Sets a client event listener, for unsolicited subscription PDUs, that reacts to an error PDU
 * // by restarting the client connection. The PDU is passed as a parameter.
 * rtm.on('data', function (pdu) {
 *   if (pdu.action.endsWith('/error')) {
 *     rtm.restart();
 *   }
 *
 * rtm.start();
 *
 * @see {@link RTM.SubscriptionMode.SIMPLE}
 * @see {@link RTM.SubscriptionMode.RELIABLE}
 * @see {@link RTM.SubscriptionMode.ADVANCED}
 */
RTM.prototype.subscribe = function (channelOrSubId, mode, bodyOpts) {
  var containsKeys = function (map, keys) {
    return keys.reduce(function (acc, k) {
      return acc && {}.hasOwnProperty.call(map, k);
    }, true);
  };
  var subscription;
  var pdu;
  var opts;
  var modeMandatoryKeys = ['fastForward', 'trackPosition'];

  if (typeof channelOrSubId !== 'string') {
    throw new TypeError('"channelOrSubId" is missing or invalid');
  }

  if (!(typeof mode === 'object') || !containsKeys(mode, modeMandatoryKeys)) {
    throw new TypeError('Subscription mode has incorrect value: ' + mode + '\n' +
                        'Mode should contains the following mandatory fields: ' + modeMandatoryKeys.join(', ') + '\n' +
                        'See also: RTM.SubscriptionMode.SIMPLE, RTM.SubscriptionMode.ADVANCED, RTM.SubscriptionMode.RELIABLE');
  }

  if (this.subscriptions[channelOrSubId]) {
    throw new Error('Cannot create subscription ' + subscription + ' twice');
  }

  opts = objectAssign({}, mode, { bodyOpts: bodyOpts });
  subscription = new Subscription(channelOrSubId, opts);
  this.subscriptions[channelOrSubId] = subscription;
  if (this.isConnected()) {
    pdu = subscription.subscribePdu(this._nextId());
    this._send(pdu, function (sp) {
      subscription.onPdu(sp);
    });
  }
  return subscription;
};

/**
 * Updates an existing [Subscription]{@link Subscription} object. Existing
 * [Subscription]{@link Subscription} event handlers are copied to the updated object.
 *
 * Use this method to change an existing subscription. For example, use it to add or change a
 * streamview.
 *
 * @param {string} channelOrSubId - subscription id or channel name for
 * the existing subscription
 *
 * @param {Object} opts
 * Properties for the updated <code>Subscription</code> object. See
 * [RTM.subscribe(channelOrSubId, opts)]{@link #subscribe} for the supported property names.
 *
 * @param {Function} [onCompleted]
 * function to execute on the updated <code>Subscription</code> object
 *
 * @throws {TypeError} thrown if mandatory parameters are missing or invalid.
 *
 * @return {void}
 */
RTM.prototype.resubscribe = function (channelOrSubId, mode, bodyOpts, onCompleted) {
  var self = this;
  var prevSub;
  var newSub;
  if (typeof channelOrSubId !== 'string') {
    throw new TypeError('"channelOrSubId" is missing or invalid');
  }
  prevSub = self.subscriptions[channelOrSubId];
  self.unsubscribe(channelOrSubId, function () {
    newSub = self.subscribe(channelOrSubId, mode, bodyOpts);
    newSub.handlers = prevSub.handlers;
    if (onCompleted) {
      onCompleted(newSub);
    }
  });
};


/**
 * Removes the specified subscription.
 *
 * @param {string} subscriptionId - Subscription id or channel name.
 *
 * @param {Function} [onAck]
 * Callback function that's invoked when RTM responds to the unsubscribe request. RTM passes the
 * response PDU to this function. If you don't specify <code>onAck</code>, RTM doesn't send a
 * response PDU.
 *
 * @throws {TypeError} thrown if required parameters are missing or invalid
 *
 * @return {void}
 */
RTM.prototype.unsubscribe = function (subscriptionId, onAck) {
  var self = this;
  var sub;
  var onUnsubscribed;
  var pdu;
  if (typeof subscriptionId !== 'string') {
    throw new TypeError('"subscriptionId" is missing or invalid');
  }
  sub = self.subscriptions[subscriptionId];
  if (!sub) {
    throw new Error('Unknown subscription ' + subscriptionId);
  }

  // This method is called when rtm/unsubscribe/(ok|error) is returned.
  // If client is disconnected this method is called immediately without argument.
  onUnsubscribed = function (unsubscribeReplyPdu) {
    if (unsubscribeReplyPdu) {
      sub.onPdu(unsubscribeReplyPdu);
    }
    delete self.subscriptions[subscriptionId];
    if (onAck) {
      onAck(unsubscribeReplyPdu);
    }
  };
  if (sub.isSubscribed) {
    pdu = sub.unsubscribePdu(self._nextId());
    self._send(pdu, onUnsubscribed);
  } else {
    onUnsubscribed();
  }
};

/**
 * Publishes a message to a channel. The client must be connected.
 *
 * @example
 * // Publishes to the channel named "channel", and provides a callback function that's invoked when
 * // RTM responds to the request. If the PDU "action" value doesn't end with "ok", the function
 * // logs an error.
 * rtm.publish('channel', {key: 'value'}, function (pdu) {
 *   if (!pdu.action.endsWith('/ok')) {
 *     console.log('something went wrong');
 *   }
 * });
 *
 * @param {string} channel - channel name
 *
 * @param {JSON} message
 * JSON containing the message to publish
 *
 * @param {Function} [onAck]
 * Callback function that's invoked when RTM responds to the publish request. RTM passes the
 * response PDU to this function. If you don't specify <code>onAck</code>, RTM doesn't send a
 * response PDU.
 *
 * @throws {TypeError} thrown if required parameters are missing or invalid
 *
 * @return {void}
 */
RTM.prototype.publish = function (channel, message, onAck) {
  var command;
  if (typeof channel !== 'string') {
    throw new TypeError('"channel" is missing or invalid');
  }
  if (typeof message === 'undefined') {
    throw new TypeError('"message" is missing');
  }
  command = {
    action: 'rtm/publish',
    body: {
      channel: channel,
      message: message,
    },
  };
  return this._send(command, onAck);
};

/**
 * Reads the latest message written to a specific channel, as a Protocol
 * Data Unit (<strong>PDU</strong>). The client must be connected.
 *
 * @variation 1
 *
 * @param {string} channel - name of the channel to read from
 *
 * @param {Function} [onAck]
 * Callback function that's invoked when RTM responds to the publish request. RTM passes the
 * response PDU to this function. If you don't specify <code>onAck</code>, RTM doesn't send a
 * response PDU.
 *
 * @example
 * // Reads from the channel named 'channel' and prints the response PDU
 * rtm.read('channel', function (pdu) {
 *     console.log(pdu);
 * })
 *
 * @throws {TypeError} thrown if required parameters are missing or invalid
 *
 * @return {void}
 *
 * @also
 *
 * Reads the latest message written to specific channel, as a Protocol
 * Data Unit (<strong>PDU</strong>). The client must be connected.
 *
 * @variation 2
 *
 * @param {string} channel - name of the channel to read from
 *
 * @param {object} [opts={}]
 * Additional options in the read PDU that's sent to RTM in the request.
 * For more information, see the section "Read PDU" in the "RTM API" chapter of <em>Satori Docs/em>.
 *
 * @param {object} [opts.bodyOpts={}]
 * Additional options in the <code>body</code> element of the read PDU that's sent to
 * RTM in the request.
 *
 * @param {Function} [opts.onAck]
 * Callback function that's invoked when RTM responds to the publish request. RTM passes the
 * response PDU to this function. If you don't specify <code>onAck</code>, RTM doesn't send a
 * response PDU.
 *
 * @example
 * // Reads from the channel named 'channel', starting at the position specified by the
 * // "position" key.
 * // Prints the response PDU.
 * rtm.read('channel', {
 *   bodyOpts: { position: '1485444476:0' },
 *   onAck: function (pdu) {
 *     console.log(pdu);
 *   }
 * })
 *
 * @throws {TypeError} thrown if required parameters are missing or invalid
 *
 * @return {void}
 */
RTM.prototype.read = function (channel, onAckOrOpts) {
  var command;
  var opts;
  if (typeof channel !== 'string') {
    throw new TypeError('"channel" is missing or invalid');
  }
  if (typeof onAckOrOpts === 'function') {
    opts = { onAck: onAckOrOpts };
  } else {
    opts = onAckOrOpts;
  }
  command = {
    action: 'rtm/read',
    body: objectAssign({}, opts.bodyOpts, { channel: channel }),
  };
  return this._send(command, opts.onAck);
};

/**
 * Writes a value to the specified channel. The client must be connected.
 *
 * @param {string} channel - name of the channel to write to
 *
 * @param {JSON} value
 * JSON containing the PDU to write to the channel
 *
 * @param {Function} [onAck]
 * Callback function that's invoked when RTM responds to the publish request. RTM passes the
 * response PDU to this function. If you don't specify <code>onAck</code>, RTM doesn't send a
 * response PDU.
 *
 * @example
 * // Writes the string 'value' to the channel named 'channel' and prints the response PDU.
 * rtm.write('channel', 'value', function (pdu) {
 *     console.log(pdu);
 * })
 *
 * @throws {TypeError} thrown if required parameters are missing or invalid
 *
 * @return {void}
 */
RTM.prototype.write = function (channel, value, onAck) {
  var command;
  if ((typeof channel !== 'string')) {
    throw new TypeError('"channel" is missing or invalid');
  }
  if (typeof value === 'undefined') {
    throw new TypeError('"value" is missing or invalid');
  }
  command = {
    action: 'rtm/write',
    body: { channel: channel, message: value },
  };
  return this._send(command, onAck);
};

/**
 * Deletes the value for the associated channel. The [RTM]{@link RTM} client must be connected.
 *
 * @param {string} channel - Channel name.
 *
 * @param {Function} [onAck]
 * Callback function that's invoked when RTM responds to the publish request. RTM passes the
 * response PDU to this function. If you don't specify <code>onAck</code>, RTM doesn't send a
 * response PDU.
 *
 * @example
 * rtm.delete('channel', function (pdu) {
 *     console.log(pdu);
 * })
 *
 * @throws {TypeError} thrown if required parameters are missing or invalid
 *
 * @return {void}
 */
RTM.prototype.delete = function (channel, onAck) {
  var command;
  if (typeof channel !== 'string') {
    throw new TypeError('"channel" is missing or invalid');
  }
  command = {
    action: 'rtm/delete',
    body: { channel: channel },
  };
  return this._send(command, onAck);
};

/**
 * Performs a channel search for a given user-defined prefix. This method passes
 * replies to the callback. The [RTM]{@link RTM} client must be connected.
 *
 * RTM may send multiple responses to the same search request: zero or
 * more search result PDUs with an action of <code>rtm/search/data</code>
 * (depending on the results of the search). Each channel found is only sent
 * once. After the search result PDUs, RTM follows with a positive response PDU:
 * <code>rtm/search/ok</code>.
 *
 * Otherwise, RTM sends an error PDU with an action of <code>rtm/search/error</code>.
 *
 * @param {string} prefix - Channel prefix.
 *
 * @param {Function} [onAck]
 * Function to attach and execute on the response PDU from
 * RTM. The response PDU is passed as a parameter to this function.
 * RTM does not send a response PDU if a callback is not specified.
 *
 * @example
 * var channels = [];
 * rtm.search('ch', function (pdu) {
 *     channels = channels.concat(pdu.body.channels);
 *     if (pdu.action === 'rtm/search/ok') {
 *       console.log(channels);
 *     }
 * })
 *
 * @throws {TypeError} <code>TypeError</code> indicates that mandatory
 * parameters are missing or invalid.
 *
 * @return {void}
 */
RTM.prototype.search = function (prefix, onAck) {
  var command;
  if (typeof prefix !== 'string') {
    throw new TypeError('"prefix" is missing or invalid');
  }
  command = {
    action: 'rtm/search',
    body: { prefix: prefix },
  };
  return this._send(command, onAck);
};

// Private methods

RTM.prototype._initHeartbeatInterval = function () {
  var self = this;
  var heartbeatTimer;
  var interval = this.options.heartbeatInterval;

  this.on('open', function () {
    var pingTimestamp = 0;
    var pongTimestamp = 0;
    heartbeatTimer = setInterval(function () {
      if (pongTimestamp < pingTimestamp) {
        self._disconnect();
        return;
      }
      pingTimestamp = Date.now();
      self.publish('$heartbeat', '', function () {
        pongTimestamp = Date.now();
      });
    }, interval);
  });

  this.on('close', function () {
    clearInterval(heartbeatTimer);
  });
};

RTM.prototype._initWritableState = function () {
  var self = this;
  var writableStateTimer;
  var interval = this.options.checkWritabilityInterval;

  this.on('open', function () {
    self._setWritableState(true);
    writableStateTimer = setInterval(function () {
      self._checkWritableState();
    }, interval);
  });

  this.on('close', function () {
    clearInterval(writableStateTimer);
    self._setWritableState(false);
  });
};

RTM.prototype._checkWritableState = function () {
  if (this.writable && this.ws.bufferedAmount > this.options.highWaterMark) {
    this._setWritableState(false);
  } else if (!this.writable && this.ws.bufferedAmount < this.options.lowWaterMark) {
    this._setWritableState(true);
  }
};

RTM.prototype._setWritableState = function (newState) {
  if (this.writable !== newState) {
    this.writable = newState;
    this.fire('change-writability', this.writable);
  }
};

RTM.prototype._connect = function () {
  var self = this;
  var ws;
  logger.debug('Connecting to', this.endpoint);
  if ('proxyAgent' in this.options) {
    logger.debug('   (using proxy agent)');
  }
  ws = this.ws = new W3CWebSocket(this.endpoint, [], {
    perMessageDeflate: false,
    agent: this.options.proxyAgent,
  });
  ws.onopen = function () {
    self.fire('open');
  };
  ws.onmessage = function (message) {
    var json;
    try {
      logger.debug('recv<', message.data);
      json = JSON.parse(message.data);
      self._recv(json);
      self.fire('data', json);
    } catch (error) {
      self.fire('error', error);
    }
  };
  ws.onerror = function (error) {
    self.fire('error', error);
  };
  ws.onclose = function () {
    if (self.ws === ws) {
      self.ws = null;
      self.fire('close');
    }
  };
};

RTM.prototype._send = function (pdu, onAck) {
  if (!this.isConnected()) {
    throw new Error('Client is not connected');
  }
  return this._unsafeSend(pdu, onAck);
};

RTM.prototype._unsafeSend = function (origPdu, onAck) {
  var pdu = objectAssign({}, origPdu);
  var json;
  if (onAck) {
    pdu.id = 'id' in pdu ? pdu.id : this._nextId();
    this.ackCallbacks.set(pdu.id, onAck);
  }
  json = JSON.stringify(pdu);
  logger.debug('send>', json);
  try {
    this.ws.send(json, {
      mask: this.maskMessage,
    });
  } catch (error) {
    this.fire('error', error);
  }
  this._checkWritableState();
};

RTM.prototype._recv = function (pdu) {
  var subscriptionId;
  var subscription;
  var ack;
  // standalone versions because `startsWith` && `endsWith` appeared in ES6 only
  var startsWith = function (str, prefix) {
    return str.substr(0, prefix.length) === prefix;
  };
  var endsWith = function (str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  if (pdu.body && ('subscription_id' in pdu.body) && startsWith(pdu.action, 'rtm/subscription/')) {
    subscriptionId = pdu.body.subscription_id;
    subscription = this.subscriptions[subscriptionId];
    if (subscription) {
      subscription.onPdu(pdu);
    }
  }
  if ('id' in pdu) {
    ack = this.ackCallbacks.get(pdu.id);
    if (ack) {
      if (!endsWith(pdu.action, '/data')) {
        this.ackCallbacks.delete(pdu.id);
      }
      ack(pdu);
    }
  }
};

RTM.prototype._disconnect = function () {
  var ws = this.ws;
  if (ws) {
    ws.onclose();
    ws.onclose = null;
    ws.close();
  }
  this.ackCallbacks.clear();
};

RTM.prototype._nextId = function () {
  this.lastId += 1;
  return this.lastId;
};

RTM.prototype._nextReconnectInterval = function () {
  var THRESHOLD_FAIL_COUNT = 30;
  var minReconnectInterval = this.options.minReconnectInterval;
  var maxReconnectInterval = this.options.maxReconnectInterval;
  var jitter = Math.random() * this.options.minReconnectInterval;
  var count = Math.min(this.reconnectCount, THRESHOLD_FAIL_COUNT);
  var interval = Math.min(maxReconnectInterval,
      jitter + (minReconnectInterval * Math.pow(2, count)));
  return interval;
};

RTM.prototype._forEachSubscription = function (fn) {
  var self = this;
  Object.keys(self.subscriptions).forEach(function (subscriptionId) {
    if ({}.hasOwnProperty.call(self.subscriptions, subscriptionId)) {
      fn(subscriptionId, self.subscriptions[subscriptionId]);
    }
  });
};

RTM.prototype._subscribeAll = function () {
  var self = this;
  this._forEachSubscription(function (subscriptionId, subscription) {
    var pdu = subscription.subscribePdu(self._nextId());
    self._send(pdu, function (sp) {
      subscription.onPdu(sp);
    });
  });
};

RTM.prototype._disconnectAll = function () {
  this._forEachSubscription(function (subscriptionId, subscription) {
    subscription.onDisconnect();
  });
};

RTM.prototype._isEndpointSecure = function (endpoint) {
  if (endpoint.indexOf('wss://') === 0) {
    return true;
  }

  return false;
};

// Connection Finite State Machine
//
STATES[STOPPED] = {
  _enter: function () {
    this._disconnect();
  },
  _leave: function () {},
  start: function () {
    this._transition(CONNECTING);
  },
  close: function () {},
};
STATES[CONNECTING] = {
  _enter: function () {
    try {
      this._connect();
    } catch (e) {
      this.fire('error', e);
    }
  },
  _leave: function () {},
  open: function () {
    var self = this;
    var onsuccess;
    var onfail;
    this.lastId = 0;
    if (this.options.authProvider) {
      onsuccess = function () {
        self.fire('authenticated');
        self._transition(CONNECTED);
      };
      onfail = function (e) {
        self.fire('error', e);
      };
      this.options.authProvider(this, onsuccess, onfail);
    } else {
      this._transition(CONNECTED);
    }
  },
  error: function () {
    this._transition(AWAITING);
  },
  close: function () {
    this._transition(AWAITING);
  },
  stop: function () {
    this._transition(STOPPED);
  },
};

STATES[CONNECTED] = {
  _enter: function () {
    this.reconnectCount = 0;
    this._subscribeAll();
  },
  _leave: function () {
    this._disconnectAll();
  },
  close: function () {
    this._transition(AWAITING);
  },
  stop: function () {
    this._transition(STOPPED);
  },
};

STATES[AWAITING] = {
  _enter: function () {
    var self = this;
    var interval;
    this._disconnect();
    interval = this._nextReconnectInterval();
    this.reconnectTimer = setTimeout(function () {
      self.reconnectCount += 1;
      self._transition(CONNECTING);
    }, interval);
  },
  _leave: function () {
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
    }
    this.reconnectTimer = null;
  },
  stop: function () {
    this._transition(STOPPED);
  },
  close: function () { },
};

RTM.prototype._initConnectionFSM = function () {
  var self = this;
  var events = [
    'open',
    'close',
    'error',
    'start',
    'stop',
    'reconnect',
  ];
  this._transition(STOPPED);
  events.forEach(function (ev) {
    self.on(ev, function () {
      self._safelyCallFSMEvent(ev);
    });
  });
};

RTM.prototype._safelyCallFSMEvent = function (ev) {
  var fn = STATES[this.state][ev];
  logger.debug('FSM event:', ev, 'Current state:', this.state);
  if (fn) {
    try {
      fn.call(this);
    } catch (error) {
      logger.error(error, 'Unexpected error during event callback call', this.state, ev);
    }
  } else {
    logger.warn('Nothing to do for event', ev, this.state);
  }
};

RTM.prototype._transition = function (newState) {
  logger.debug('Transition from', this.state, 'to', newState);
  if (this.state) {
    this._safelyCallFSMEvent('_leave');
    this.fire('leave-' + this.state);
  }
  this.state = newState;
  this._safelyCallFSMEvent('_enter');
  this.fire('enter-' + this.state);
};

RTM.prototype._appendVersion = function (ep) {
  var versionMatch = ep.match(/\/(v\d+)$/);
  var ret = ep;
  var ver;

  if (versionMatch !== null) {
    ver = versionMatch[1];
    logger.warn(
        'satori-rtm-sdk: specifying RTM endpoint with protocol version is deprecated.\n' +
        'satori-rtm-sdk: please remove version \'' + ver + '\' from endpoint:\'' + ep + '\''
    );
    return ret;
  }

  if (ret[ret.length - 1] !== '/') {
    ret += '/';
  }

  return ret + RTM_VER;
};

module.exports = RTM;

},{"./auth.js":8,"./logger.js":9,"./map.js":10,"./observer.js":11,"./subscription.js":13,"./websocket.js":14,"object-assign":7}],13:[function(require,module,exports){
var Observer = require('./observer.js');
var objectAssign = require('object-assign');

/**
 * Creates an instance of a subscription. This function inherits functions from
 * [Observer.js]{@link Observer}, such as [on(event, fn)]{@link Observer#on}
 * @class
 * @augments Observer
 *
 * @description
 * <code>Subscription</code> represents a subscription to a channel. Its functions manage the
 * subscription state and respond to subscription events.
 *
 * Use <code>Subscription</code> functions to specify code that executes when an event occurs or
 * when the subscription enters a specific state.
 *
 * For example, use <code>Subscription.on("rtm/subscription/data", fn())</code> to specify a
 * function that's executed when the subscription receives a message. Use
 * <code>Subscription.on("enter-subscribed", fn())</code> to specify a function that's executed
 * when the subscription is active.
 *
 * When your application receives a channel message, the <code>data</code> event occurs and the
 * message is passed as a Protocol Data Unit (<strong>PDU</strong>) to the function specified for
 * <code>Subscription.on("rtm/subscription/data", fn())</code>.
 *
 * You can also specify an event handler function that executes when the subscription enters or
 * leaves subscribed state. For example, to specify an event handler for the
 * <code>enter-subscribed</code> event, use <code>Subscription.on("enter-subscribed", fn()}</code>.
 *
 * <strong>Note:</strong> When the connection from the client to RTM drops, all subscriptions are
 * unsubscribed and then resubscribed when the connection is restored.
 *
 * @example
 * // Creates an RTM client
 * var rtm = new RTM('YOUR_ENDPOINT', 'YOUR_APPKEY');
 * // create a new subscription to the channel named 'your-channel'
 * var subscription = rtm.subscribe('your-channel');
 *
 * subscription.on('rtm/subscription/data', function (pdu) {
 *     pdu.body.messages.forEach(console.log);
 * });
 * subscription.on('enter-subscribed', function () {
 *     console.log('Subscribed!');
 * });
 * subscription.on('data', function (pdu) {
 *     if (pdu.action.endWith('/error')) {
 *         rtm.restart();
 *     }
 * });
 *
 * @param {string} subscriptionId - unique identifier for the subscription. If you don't use the
 * <code>filter</code> parameter to specify a streamview, subscriptionId is treated as a channel
 * name.
 *
 * @param {Object} opts - additional subscription options
 *
 * @param {boolean} [opts.mode] - subscription mode
 *
 * @param {object} [opts.bodyOpts={}]
 * Additional options for the subscription. These options are sent to RTM in the <code>body</code>
 * element of the PDU that represents the subscribe request.
 *
 * @throws {TypeError} indicates that mandatory parameters are missing or invalid.
 *
 */
function Subscription(subscriptionId, _opts) {
  if (typeof subscriptionId !== 'string') {
    throw new TypeError('"subscriptionId" is missing or invalid');
  }
  Observer.call(this);

  this.options = objectAssign({}, _opts);
  if (typeof this.options.bodyOpts !== 'object') {
    this.options.bodyOpts = {};
  }
  if (this.options.fastForward) {
    this.options.bodyOpts.fast_forward = true;
  }

  this.position = null;
  this.subscriptionId = subscriptionId;
  this.wasSubscribedAtLeastOnce = false;
  this.isSubscribed = false;
  /* eslint-enable camelcase */
}

Subscription.prototype = Object.create(Observer.prototype);

Subscription.prototype.subscribePdu = function (id) {
  var body;

  // inherit all users options like 'filter', 'fast_forward'
  if (this.options.bodyOpts.filter) {
    body = { subscription_id: this.subscriptionId };
  } else {
    body = { channel: this.subscriptionId };
  }

  body = objectAssign(body, this.options.bodyOpts);

  if (this.wasSubscribedAtLeastOnce) {
    if (this.position !== null) {
      body.position = this.position;
    } else {
      delete body.position;
    }
  }
  return {
    id: id,
    action: 'rtm/subscribe',
    body: body,
  };
};

Subscription.prototype.unsubscribePdu = function (id) {
  return {
    id: id,
    action: 'rtm/unsubscribe',
    body: { subscription_id: this.subscriptionId },
  };
};

Subscription.prototype.onPdu = function (pdu) {
  var body = pdu.body;
  if (body && body.position) {
    this._onPosition(body.position);
  }
  if (pdu.action === 'rtm/subscribe/ok') {
    this.isSubscribed = true;
    this.wasSubscribedAtLeastOnce = true;
    this.fire('enter-subscribed');
  }
  if (pdu.action === 'rtm/unsubscribe/ok') {
    this._markAsUnsubscribed();
  }
  if (pdu.action === 'rtm/subscription/error') {
    this._markAsUnsubscribed();
  }
  this.fire('data', pdu, this);
  this.fire(pdu.action, pdu, this);
};

Subscription.prototype.onDisconnect = function () {
  this._markAsUnsubscribed();
};

Subscription.prototype._onPosition = function (position) {
  if (this.options.trackPosition) {
    this.position = position;
  }
  this.fire('position', position, this);
};

Subscription.prototype._markAsUnsubscribed = function () {
  if (this.isSubscribed) {
    this.isSubscribed = false;
    this.fire('leave-subscribed');
  }
};

module.exports = Subscription;

},{"./observer.js":11,"object-assign":7}],14:[function(require,module,exports){
var _global = (function () {
  return this;
}());
var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;

function W3CWebSocket(uri) {
  return new NativeWebSocket(uri);
}

module.exports = NativeWebSocket ? W3CWebSocket : null;

},{}]},{},[12])(12)
});